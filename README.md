# README.md

## Описание проекта
Это простое приложение на FastAPI, демонстрирующее основные возможности работы с SQLAlchemy. В рамках проекта реализованы следующие задачи:

1. **Оптимизация загрузки данных**  
   - Созданы модели `Author` и `Book` с отношением "один ко многим".
   - Реализованы два эндпоинта для получения авторов:  
     - **Ленивая загрузка**: при обращении к связанным книгам выполняется дополнительный запрос (N+1).
     - **Жадная загрузка**: с использованием `joinedload` все данные загружаются одним SQL-запросом.
   - **Вывод**: Использование жадной загрузки помогает избежать проблемы N+1 и повышает производительность при выборке связанных объектов.

2. **Транзакции и откаты изменений**  
   - Создана модель `User`.
   - Эндпоинт демонстрирует транзакционное добавление двух пользователей с имитацией ошибки при добавлении третьего.
   - При возникновении ошибки транзакция откатывается, и база данных остается в неизменном состоянии.
   - **Вывод**: Использование транзакций с автоматическим откатом обеспечивает целостность данных при возникновении ошибок.

3. **Работа с Alembic**  
   - В проекте даны пошаговые инструкции по инициализации Alembic, созданию миграций для таблицы `Order`, внесению изменений (добавление поля `price`, удаление поля `created_at`) и последующему откату миграций.
   - **Вывод**: Alembic облегчает управление версионностью схемы базы данных и позволяет легко вносить изменения в структуру таблиц.

4. **Паттерн Repository**  
   - Реализован паттерн Repository для модели `Book` с методами добавления книги, получения всех книг автора по его `id` и удаления книги.
   - Использование фабрики сессий для управления соединениями с базой данных.
   - **Вывод**: Паттерн Repository помогает инкапсулировать логику доступа к данным, делая код более читаемым и удобным для тестирования.

5. **Логирование и объединение ORM и Core**  
   - Логирование SQL-запросов включено с помощью параметра `echo=True` в `create_engine`, что позволяет отслеживать сгенерированные запросы.
   - Реализован сложный агрегирующий запрос с использованием SQLAlchemy Core для подсчёта количества книг у каждого автора, в то время как ORM используется для большинства CRUD операций.
   - **Вывод**: Комбинированное использование SQLAlchemy ORM и Core позволяет гибко работать с базой данных, используя преимущества обоих подходов для различных типов запросов.

## Инструкции по запуску
1. **Установка зависимостей**  
   Установите необходимые пакеты:
   ```bash
   pip install fastapi uvicorn sqlalchemy pydantic
   ```


## **Тестирование эндпоинтов:**

- Запустите приложение.
    ```bash
    uvicorn main:app --reload
    ```
**Swagger UI**

   - Откройте браузер и перейдите по адресу [http://127.0.0.1:8000/docs](http://127.0.0.1:8000/docs).  
     Здесь вы увидите интерактивную документацию FastAPI, где можно протестировать все созданные эндпоинты.
     ![image](https://github.com/user-attachments/assets/1516e50b-191d-4012-bfed-13f0336f2f13)


   - **Задача 1 (Ленивая и жадная загрузка):**  
     - GET `/authors/lazy` – получаем авторов с ленивой загрузкой.  
     - GET `/authors/eager` – получаем авторов с жадной загрузкой (joinedload).

   - **Задача 2 (Транзакции и откат):**  
     - POST `/users/transaction` – попробуйте создать пользователей; транзакция будет откатана из-за искусственной ошибки.

   - **Задача 3 (Alembic):**  
     - GET `/alembic/instructions` – ознакомьтесь с инструкциями по работе с Alembic в комментариях.

   - **Задача 4 (Паттерн Repository для Book):**  
     - POST `/books/add` – добавление новой книги. 
            ```
            {
            "title": "Избранное",
            "author_id": 1
            }
            ```


     - GET `/books/by_author/{author_id}` – получение книг по id автора.  
         ```
     [
  {
    "id": 1,
    "title": "Реквием",
    "author_id": 1
  },
  {
    "id": 2,
    "title": "Поэма без героя",
    "author_id": 1
    },
    {
    "id": 3,
    "title": "Избранное",
    "author_id": 1
    }
    ]
        ```
     - DELETE `/books/{book_id}` – удаление книги по id.

   - **Задача 5 (Логирование и ORM+Core):**  
     - GET `/authors/book_counts` – агрегирующий запрос с использованием SQLAlchemy Core, который возвращает количество книг у каждого автора.

5. **Анализ SQL-запросов:**

   Так как в `create_engine` установлен параметр `echo=True`, все сгенерированные SQL-запросы будут выводиться в консоль. Это позволит вам наблюдать за работой запросов, их оптимизацией (например, при использовании `joinedload`) и объединением ORM и Core.

